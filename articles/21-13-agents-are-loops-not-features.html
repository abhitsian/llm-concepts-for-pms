<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Agents Are Loops, Not Features</title>
  <link rel="stylesheet" href="../css/style.css">
</head>
<body>
  <div class="bezier-hero"><canvas id="bezier-canvas"></canvas></div>
  <div class="article-card">
    <div class="article-meta">601 words</div><h1>Agents Are Loops, Not Features</h1><div class="article-subtitle">Part 13 of LLM Concepts for PMs</div><div class="divider">╌╌╌╌</div><hr />

<p>Strip away the marketing language &amp; an agent is a loop. An LLM makes a call, reads the result, decides what to do next, makes another call, &amp; keeps going until it’s done or hits a boundary. Plan, execute, observe, adjust, repeat. The power comes from the loop, not from some new category of intelligence — &amp; understanding the loop changes how you think about cost, failure, trust, &amp; product design.</p>
<p>A standard LLM interaction is a single shot — one prompt, one response, one bill. An agent might make that same kind of call ten or twenty times per task, each pass consuming tokens to reason about prior results &amp; formulate the next action. Your cost per task becomes a distribution with a long tail. A coding agent fixing a simple bug might take three loops &amp; cost cents. The same agent on an ambiguous refactoring might spiral through forty loops, backtrack twice, &amp; burn dollars before arriving at something useful — or nothing useful at all.</p>
<p>The failure modes are what separate agents from everything prior in LLM product design. An agent that takes a wrong turn early &amp; then spends fifteen iterations building on it is expensive &amp; potentially destructive. They can loop indefinitely without stopping conditions, get stuck retrying the same failing approach with minor variations, or confidently execute a plan where step two was wrong — meaning every subsequent step is wasted work on a bad foundation. You need circuit breakers: hard limits on iterations, token budgets, timeouts. Circuit breakers mean some tasks fail partway through, &amp; how you communicate partial failure to a user is a product design problem, not an engineering afterthought.</p>
<h2 id="the-spectrum-the-trust-boundary">The spectrum &amp; the trust boundary</h2>
<p>There’s a spectrum between a single LLM call &amp; a full autonomous agent, &amp; most production use cases belong in the middle. A chain is a predetermined sequence of calls — summarize, extract, generate — where steps are fixed &amp; predictable. An agent sits at the far end, where the LLM decides what to do next at each step. Ppl skip straight to agents cuz the concept is exciting, when a well-designed chain would handle 80% of the work at a fraction of the cost. Each step in a chain is debuggable &amp; individually testable. Wrap those same steps in an agent loop &amp; you gain flexibility at the expense of observability — the agent handles edge cases a chain would miss, but it also invents failure modes a chain would never produce.</p>
<p>Agents that generate text operate in a different trust regime than agents that take actions. A chatbot that writes a bad email draft wastes your time; an agent that sends it wastes your reputation. Coding agents work cuz the trust model is manageable — the agent proposes, a human reviews before shipping. Agents that issue refunds, modify accounts, or send communications need guardrails that are themselves product features: confirmation steps, audit logs, rollback capabilities, scope limitations. Designing those guardrails is often more work than building the loop itself.</p>
<p>Think about agents the way you’d think about a new employee. Start them on constrained tasks, review their work, gradually expand autonomy as they prove reliable — except “proving reliable” requires evals &amp; monitoring infrastructure rather than gut feel. Start with chains. Add agent-like flexibility where the chains break down. Expand autonomy where you can measure outcomes &amp; absorb failures. The loop is powerful, but a loop without boundaries is just an expensive way to generate surprises.</p><div class="end-mark">╌╌ end ╌╌</div>
  </div>
  <nav class="article-nav">
  <a href="20-16-tools-gave-models-hands.html">&larr; Tools Gave Models Hands</a>
  <a class="nav-index" href="../index.html">Index</a>
  <a href="22-14-reasoning-models-changed-the-ceiling.html">Reasoning Models Changed the Ceiling &rarr;</a>
</nav>
  <script src="../js/bezier-core.js"></script>
<script src="../js/diagrams/agents-loops.js"></script>
<script>
  document.addEventListener('DOMContentLoaded', function() {
    var canvas = document.getElementById('bezier-canvas');
    var container = canvas.parentElement;
    AgentsLoopsDiagram(canvas, container);
  });
</script>
</body>
</html>